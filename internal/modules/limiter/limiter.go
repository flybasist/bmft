package limiter

import (
	"database/sql"
	"fmt"
	"strconv"
	"strings"

	"github.com/flybasist/bmft/internal/core"
	"github.com/flybasist/bmft/internal/postgresql/repositories"
	"go.uber.org/zap"
	"gopkg.in/telebot.v3"
)

type LimiterModule struct {
	vipRepo           *repositories.VIPRepository
	contentLimitsRepo *repositories.ContentLimitsRepository
	logger            *zap.Logger
	bot               *telebot.Bot
}

func New(
	vipRepo *repositories.VIPRepository,
	contentLimitsRepo *repositories.ContentLimitsRepository,
	logger *zap.Logger,
	bot *telebot.Bot,
) *LimiterModule {
	return &LimiterModule{
		vipRepo:           vipRepo,
		contentLimitsRepo: contentLimitsRepo,
		logger:            logger,
		bot:               bot,
	}
}

func (m *LimiterModule) Name() string {
	return "limiter"
}

func (m *LimiterModule) Init(deps core.ModuleDependencies) error {
	m.logger.Info("limiter module initialized")
	return nil
}

func (m *LimiterModule) Commands() []core.BotCommand {
	return []core.BotCommand{
		{Command: "/mystats", Description: "–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–≤–æ—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏ –ª–∏–º–∏—Ç—ã"},
	}
}

func (m *LimiterModule) Enabled(chatID int64) (bool, error) {
	return true, nil
}

func (m *LimiterModule) OnMessage(ctx *core.MessageContext) error {
	msg := ctx.Message
	if msg.Private() {
		return nil
	}

	chatID := msg.Chat.ID
	userID := msg.Sender.ID

	m.logger.Debug("limiter: received message",
		zap.Int64("chat_id", chatID),
		zap.Int64("user_id", userID),
		zap.String("username", msg.Sender.Username),
		zap.String("text", msg.Text),
	)

	isVIP, err := m.vipRepo.IsVIP(chatID, userID)
	if err != nil {
		m.logger.Error("limiter: failed to check VIP status", zap.Int64("chat_id", chatID), zap.Int64("user_id", userID), zap.Error(err))
	}
	if isVIP {
		m.logger.Debug("limiter: user is VIP, skipping limits", zap.Int64("chat_id", chatID), zap.Int64("user_id", userID))
		return nil
	}

	contentType := m.detectContentType(msg)
	m.logger.Debug("limiter: detected content type", zap.String("content_type", contentType))
	if contentType == "" {
		m.logger.Warn("limiter: unknown content type, skipping", zap.Int64("chat_id", chatID), zap.Int64("user_id", userID))
		return nil
	}

	limit, err := m.contentLimitsRepo.GetLimitForContentType(chatID, &userID, contentType)
	if err != nil {
		m.logger.Error("limiter: failed to get limit", zap.Error(err), zap.Int64("chat_id", chatID), zap.Int64("user_id", userID), zap.String("content_type", contentType))
		return nil
	}
	m.logger.Debug("limiter: got limit", zap.Int64("chat_id", chatID), zap.Int64("user_id", userID), zap.String("content_type", contentType), zap.Int("limit", limit))

	if limit == -1 {
		m.logger.Info("limiter: content type is banned, deleting message", zap.Int64("chat_id", chatID), zap.String("content_type", contentType))
		if err := ctx.DeleteMessage(); err != nil {
			m.logger.Error("limiter: failed to delete banned message", zap.Error(err), zap.Int64("chat_id", chatID), zap.Int64("user_id", userID), zap.String("content_type", contentType))
		} else {
			m.logger.Info("limiter: banned message deleted successfully", zap.Int64("chat_id", chatID), zap.Int64("user_id", userID), zap.String("content_type", contentType))
		}
		return nil
	}

	if limit == 0 {
		m.logger.Debug("limiter: limit is zero, skipping", zap.Int64("chat_id", chatID), zap.Int64("user_id", userID), zap.String("content_type", contentType))
		return nil
	}

	counter, err := m.contentLimitsRepo.GetCounter(chatID, userID, contentType)
	if err != nil {
		m.logger.Error("limiter: failed to get counter", zap.Error(err), zap.Int64("chat_id", chatID), zap.Int64("user_id", userID), zap.String("content_type", contentType))
		return nil
	}
	m.logger.Debug("limiter: got counter", zap.Int64("chat_id", chatID), zap.Int64("user_id", userID), zap.String("content_type", contentType), zap.Int("counter", counter))

	if counter >= limit {
		m.logger.Info("limiter: content limit exceeded, deleting message", zap.Int("counter", counter), zap.Int("limit", limit), zap.Int64("chat_id", chatID), zap.Int64("user_id", userID), zap.String("content_type", contentType))
		if err := ctx.DeleteMessage(); err != nil {
			m.logger.Error("limiter: failed to delete message after limit exceeded", zap.Error(err), zap.Int64("chat_id", chatID), zap.Int64("user_id", userID), zap.String("content_type", contentType))
		} else {
			m.logger.Info("limiter: message deleted after limit exceeded", zap.Int64("chat_id", chatID), zap.Int64("user_id", userID), zap.String("content_type", contentType))
		}
		return ctx.SendReply(fmt.Sprintf("‚õîÔ∏è @%s, –≤—ã –ø—Ä–µ–≤—ã—Å–∏–ª–∏ –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç (%d/%d)", msg.Sender.Username, counter, limit))
	}

	if err := m.contentLimitsRepo.IncrementCounter(chatID, userID, contentType); err != nil {
		m.logger.Error("limiter: failed to increment counter", zap.Error(err), zap.Int64("chat_id", chatID), zap.Int64("user_id", userID), zap.String("content_type", contentType))
	} else {
		m.logger.Debug("limiter: counter incremented", zap.Int64("chat_id", chatID), zap.Int64("user_id", userID), zap.String("content_type", contentType))
	}

	newCounter := counter + 1
	if newCounter == limit-2 || newCounter == limit-1 {
		_ = ctx.SendReply(fmt.Sprintf("‚ö†Ô∏è @%s, —É –≤–∞—Å –æ—Å—Ç–∞–ª–æ—Å—å %d –∏–∑ %d", msg.Sender.Username, limit-newCounter, limit))
	}

	return nil
}

func (m *LimiterModule) Shutdown() error {
	m.logger.Info("limiter module shutdown")
	return nil
}

func (m *LimiterModule) detectContentType(msg *telebot.Message) string {
	if msg.Photo != nil {
		return "photo"
	}
	if msg.Video != nil {
		return "video"
	}
	if msg.Sticker != nil {
		return "sticker"
	}
	if msg.Animation != nil {
		return "animation"
	}
	if msg.Voice != nil {
		return "voice"
	}
	if msg.VideoNote != nil {
		return "video_note"
	}
	if msg.Audio != nil {
		return "audio"
	}
	if msg.Document != nil {
		return "document"
	}
	if msg.Location != nil {
		return "location"
	}
	if msg.Contact != nil {
		return "contact"
	}
	if msg.Text != "" {
		return "text"
	}
	return ""
}

func (m *LimiterModule) RegisterCommands(bot *telebot.Bot) {
	bot.Handle("/mystats", m.handleMyStats)
}

func (m *LimiterModule) RegisterAdminCommands(bot *telebot.Bot) {
	bot.Handle("/setlimit", m.handleSetLimit)
	bot.Handle("/setvip", m.handleSetVIP)
	bot.Handle("/removevip", m.handleRemoveVIP)
	bot.Handle("/listvips", m.handleListVIPs)
}

func (m *LimiterModule) handleMyStats(c telebot.Context) error {
	if c.Message().Private() {
		return c.Send("üìä –í –ª–∏—á–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏—è—Ö –ª–∏–º–∏—Ç—ã –Ω–µ –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è.")
	}

	chatID := c.Chat().ID
	userID := c.Sender().ID

	isVIP, err := m.vipRepo.IsVIP(chatID, userID)
	if err != nil {
		return c.Send("‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞")
	}

	if isVIP {
		return c.Send("üëë *VIP-—Å—Ç–∞—Ç—É—Å –∞–∫—Ç–∏–≤–µ–Ω*\n\n–í—Å–µ –ª–∏–º–∏—Ç—ã –¥–ª—è –≤–∞—Å –æ—Ç–∫–ª—é—á–µ–Ω—ã!", &telebot.SendOptions{ParseMode: telebot.ModeMarkdown})
	}

	limits, err := m.contentLimitsRepo.GetLimits(chatID, &userID)
	if err != nil {
		return c.Send("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ª–∏–º–∏—Ç—ã")
	}

	text := "üìä *–í–∞—à–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:*\n\n"
	types := []struct {
		name, field string
		value       int
	}{
		{"—Ç–µ–∫—Å—Ç", "text", limits.LimitText},
		{"—Ñ–æ—Ç–æ", "photo", limits.LimitPhoto},
		{"–≤–∏–¥–µ–æ", "video", limits.LimitVideo},
		{"—Å—Ç–∏–∫–µ—Ä—ã", "sticker", limits.LimitSticker},
	}

	for _, t := range types {
		if t.value == -1 {
			text += fmt.Sprintf("üö´ %s: *–ó–ê–ü–†–ï–©–ï–ù–û*\n", t.name)
		} else if t.value == 0 {
			text += fmt.Sprintf("‚ôæ %s: *–±–µ–∑ –ª–∏–º–∏—Ç–∞*\n", t.name)
		} else {
			counter, _ := m.contentLimitsRepo.GetCounter(chatID, userID, t.field)
			emoji := "‚úÖ"
			if counter >= t.value {
				emoji = "‚õîÔ∏è"
			} else if counter >= t.value-2 {
				emoji = "‚ö†Ô∏è"
			}
			text += fmt.Sprintf("%s %s: %d –∏–∑ %d\n", emoji, t.name, counter, t.value)
		}
	}

	return c.Send(text, &telebot.SendOptions{ParseMode: telebot.ModeMarkdown})
}

func (m *LimiterModule) handleSetLimit(c telebot.Context) error {
	isAdmin, err := core.IsUserAdmin(m.bot, c.Chat(), c.Sender().ID)
	if err != nil {
		return c.Send("–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞")
	}
	if !isAdmin {
		return c.Send("‚ùå –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º")
	}

	args := strings.Fields(c.Text())
	if len(args) != 3 {
		return c.Send("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /setlimit <type> <value>\n–ü—Ä–∏–º–µ—Ä: /setlimit photo 5 (–¥–ª—è –≤—Å–µ—Ö) –∏–ª–∏ /setlimit voice 10 (—á–µ—Ä–µ–∑ –æ—Ç–≤–µ—Ç –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è)")
	}

	contentType := args[1]
	limitValue, err := strconv.Atoi(args[2])
	if err != nil || limitValue < -1 {
		return c.Send("‚ùå –ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ª–∏–º–∏—Ç–∞")
	}

	chatID := c.Chat().ID
	var userID *int64
	if c.Message().ReplyTo != nil {
		id := c.Message().ReplyTo.Sender.ID
		userID = &id
	}

	if err := m.contentLimitsRepo.SetLimit(chatID, userID, contentType, limitValue); err != nil {
		return c.Send("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ª–∏–º–∏—Ç")
	}

	if userID == nil {
		return c.Send(fmt.Sprintf("‚úÖ –õ–∏–º–∏—Ç –¥–ª—è –≤—Å–µ—Ö —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: %s = %d", contentType, limitValue))
	}
	return c.Send(fmt.Sprintf("‚úÖ –õ–∏–º–∏—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: %s = %d", contentType, limitValue))
}

func (m *LimiterModule) handleSetVIP(c telebot.Context) error {
	isAdmin, err := core.IsUserAdmin(m.bot, c.Chat(), c.Sender().ID)
	if err != nil {
		return c.Send("–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞")
	}
	if !isAdmin {
		return c.Send("‚ùå –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º")
	}

	if c.Message().ReplyTo == nil {
		return c.Send("‚ùå –û—Ç–≤–µ—Ç—å—Ç–µ —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥–æ–π –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
	}

	chatID := c.Chat().ID
	userID := c.Message().ReplyTo.Sender.ID
	grantedBy := c.Sender().ID
	reason := "VIP —Å—Ç–∞—Ç—É—Å –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º"

	if err := m.vipRepo.GrantVIP(chatID, userID, grantedBy, reason); err != nil {
		return c.Send("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏—Ç—å VIP-—Å—Ç–∞—Ç—É—Å")
	}

	return c.Send("üëë VIP-—Å—Ç–∞—Ç—É—Å –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω!")
}

func (m *LimiterModule) handleRemoveVIP(c telebot.Context) error {
	admins, err := m.bot.AdminsOf(c.Chat())
	if err != nil {
		return c.Send("–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞")
	}
	isAdmin := false
	for _, admin := range admins {
		if admin.User.ID == c.Sender().ID {
			isAdmin = true
			break
		}
	}
	if !isAdmin {
		return c.Send("‚ùå –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º")
	}

	if c.Message().ReplyTo == nil {
		return c.Send("‚ùå –û—Ç–≤–µ—Ç—å—Ç–µ —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥–æ–π –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
	}

	chatID := c.Chat().ID
	userID := c.Message().ReplyTo.Sender.ID

	if err := m.vipRepo.RevokeVIP(chatID, userID); err != nil {
		if err == sql.ErrNoRows {
			return c.Send("‚ÑπÔ∏è –£ —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ—Ç VIP-—Å—Ç–∞—Ç—É—Å–∞")
		}
		return c.Send("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–æ–∑–≤–∞—Ç—å VIP-—Å—Ç–∞—Ç—É—Å")
	}

	return c.Send("‚úÖ VIP-—Å—Ç–∞—Ç—É—Å –æ—Ç–æ–∑–≤–∞–Ω")
}

func (m *LimiterModule) handleListVIPs(c telebot.Context) error {
	admins, err := m.bot.AdminsOf(c.Chat())
	if err != nil {
		return c.Send("–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞")
	}
	isAdmin := false
	for _, admin := range admins {
		if admin.User.ID == c.Sender().ID {
			isAdmin = true
			break
		}
	}
	if !isAdmin {
		return c.Send("‚ùå –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º")
	}

	chatID := c.Chat().ID
	vips, err := m.vipRepo.ListVIPs(chatID)
	if err != nil {
		return c.Send("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ VIP")
	}

	if len(vips) == 0 {
		return c.Send("‚ÑπÔ∏è –í —ç—Ç–æ–º —á–∞—Ç–µ –Ω–µ—Ç VIP-–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π")
	}

	text := "üëë *VIP-–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏:*\n\n"
	for i, vip := range vips {
		text += fmt.Sprintf("%d. User ID: `%d`\n   –ü—Ä–∏—á–∏–Ω–∞: %s\n\n", i+1, vip.UserID, vip.Reason)
	}

	return c.Send(text, &telebot.SendOptions{ParseMode: telebot.ModeMarkdown})
}
